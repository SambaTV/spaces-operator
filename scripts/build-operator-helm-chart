#!/usr/bin/env python3
"""
Kubebuilder operator projects use kustomize and controller-gen to generate
controller manifests.

This script takes those generated manifests as inputs and generates a helm
chart for those manifests.
"""
from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser
from dataclasses import dataclass
from os import makedirs, path
from subprocess import PIPE, run
from sys import exit

ENCODING = "utf-8"

REPO_ROOT_DIR = path.realpath(path.dirname(path.dirname(__file__)))


# -----------------------------------------------------------------------------
# Define project constants from metadata
# -----------------------------------------------------------------------------

def get_metadata(name: str) -> str:
    """Return project metadata"""
    with open(name, encoding=ENCODING) as infile:
        return infile.read().strip()


APP_NAME = get_metadata("APP")
APP_NAMESPACE = APP_NAME
APP_VERSION = get_metadata("VERSION")
APP_DESCRIPTION = get_metadata("DESCRIPTION")

CHARTS_DIR = "charts"
CHART = f"{CHARTS_DIR}/{APP_NAME}"
CHART_YAML_FILE = f"{CHART}/Chart.yaml"
VALUES_YAML_FILE = f"{CHART}/values.yaml"

IMAGE_NAME = f"docker.io/sambatv/{APP_NAME}"

# -----------------------------------------------------------------------------
# Define constants used to identify and substitute text fragments in the
# input manifests generated by kustomize.
# -----------------------------------------------------------------------------

NUM_OPERATOR_NON_CRD_MANIFESTS = 9

APP_SPECIFIC_VALUES_YAML = """
# Controller-specific config

leaderElect:
  enabled: true

podDisruptionBudget:
  enabled: true

prometheus:
  enabled: true
"""

CREATION_TIMESTAMP_IN = "  creationTimestamp: null\n"
METADATA_NAMESPACE_IN = f"  namespace: {APP_NAMESPACE}\n"

LABELS_IN = """
  labels:
    control-plane: controller-manager
""".lstrip("\n")

LABELS_OUT = f"""
  labels:
    {{{{- include "{APP_NAME}.labels" . | nindent 4 }}}}
    control-plane: controller-manager
""".lstrip("\n")

CLUSTERROLEBINDING_SUBJECT_NAMESPACE_IN = f"  namespace: {APP_NAMESPACE}\n"
CLUSTERROLEBINDING_SUBJECT_NAMESPACE_OUT = f"  namespace: {{{{ .Release.Namespace }}}}"

CONFIGMAP_LEADER_ELECT_IN = """
      leaderElect: true
""".lstrip("\n")

CONFIGMAP_LEADER_ELECT_OUT = """
      leaderElect: {{ .Values.leaderElect.enabled }}
""".lstrip("\n")

DEPLOYMENT_SPEC_LABELS_IN = """
      labels:
        control-plane: controller-manager
""".lstrip("\n")

DEPLOYMENT_SPEC_LABELS_OUT = f"""
      labels:
        {{{{- include "{APP_NAME}.labels" . | nindent 8 }}}}
        control-plane: controller-manager
""".lstrip("\n")

DEPLOYMENT_SPEC_IMAGE_IN = f"image: {IMAGE_NAME}:{APP_VERSION}"
DEPLOYMENT_SPEC_IMAGE_OUT = 'image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"'

DEPLOYMENT_RESOURCES_IN = """
        resources:
          limits:
            cpu: 100m
            memory: 30Mi
          requests:
            cpu: 100m
            memory: 20Mi
""".lstrip("\n")

DEPLOYMENT_RESOURCES_OUT = """
        resources:
         {{- toYaml .Values.resources | nindent 10 }}
""".lstrip("\n")

DEPLOYMENT_EXTRA_IN = """
      securityContext:
        runAsNonRoot: true
""".lstrip("\n")

DEPLOYMENT_EXTRA_OUT = """
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      securityContext:
        {{- toYaml .Values.securityContext | nindent 8 }}
""".lstrip("\n")

CRD_KIND = "CustomResourceDefinition"
CLUSTERROLEBINDING_KIND = "ClusterRoleBinding"
CONFIGMAP_KIND = "ConfigMap"
DEPLOYMENT_KIND = "Deployment"
PDB_KIND = "PodDisruptionBudget"
PDB_TEMPLATE = f"""
{{{{- if .Values.podDisruptionBudget.enabled -}}}}
apiVersion: policy/v1
kind: {PDB_KIND}
metadata:
  labels:
    {{{{- include "{APP_NAME}.labels" . | nindent 4 }}}}
    control-plane: controller-manager
  name: {{{{ include "{APP_NAME}.fullname" . }}}}
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: {{{{ include "{APP_NAME}.name" . }}}}
      app.kubernetes.io/instance: {{{{ .Release.Name }}}}
{{{{- end }}}}
""".lstrip("\n")

RBAC_KINDS = ["ClusterRole", "ClusterRoleBinding", "Role", "RoleBinding", "ServiceAccount"]
SERVICE_MONITOR_KIND = "ServiceMonitor"


# -----------------------------------------------------------------------------
# Define code used to generate the helm chart from the input manifests
# generated by kustomize.
# -----------------------------------------------------------------------------

@dataclass
class Output:
    kind: str
    name: str
    template: str


def process_manifest(manifest: str) -> Output:
    # Get object name and kind from manifest.
    lines = manifest.split("\n")
    kind = None
    name = None
    for line in lines:
        if kind and name:
            break
        if line.startswith("kind"):
            kind = line.split(":")[1].strip()
        if line.startswith("  name"):
            name = line.split(":")[1].strip()

    # Build template from manifest.
    template = manifest.replace(LABELS_IN, LABELS_OUT)
    template = template.replace(CREATION_TIMESTAMP_IN, "")
    if kind == CLUSTERROLEBINDING_KIND:
        template = template.replace(CLUSTERROLEBINDING_SUBJECT_NAMESPACE_IN, CLUSTERROLEBINDING_SUBJECT_NAMESPACE_OUT)
    else:
        template = template.replace(METADATA_NAMESPACE_IN, "")
    if kind == CONFIGMAP_KIND:
        template = template.replace(CONFIGMAP_LEADER_ELECT_IN, CONFIGMAP_LEADER_ELECT_OUT)
        template = template + LABELS_OUT
    if kind == DEPLOYMENT_KIND:
        template = template.replace(DEPLOYMENT_SPEC_IMAGE_IN, DEPLOYMENT_SPEC_IMAGE_OUT)
        template = template.replace(DEPLOYMENT_SPEC_LABELS_IN, DEPLOYMENT_SPEC_LABELS_OUT)
        template = template.replace(DEPLOYMENT_RESOURCES_IN, DEPLOYMENT_RESOURCES_OUT)
        template = template.replace(DEPLOYMENT_EXTRA_IN, DEPLOYMENT_EXTRA_OUT)
    if kind in RBAC_KINDS:
        # This seems redundant but is needed because the initial labels replacement above
        # doesn't match, as the kustomize output for rbac resources doesn't include the
        # `control-plane: controller-manager` label found in other generated manifests.
        template = template.replace("metadata:\n", f"metadata:\n{LABELS_OUT}")
    if kind == SERVICE_MONITOR_KIND:
        template = f"{{{{- if .Values.prometheus.enabled -}}}}{template}\n{{{{- end }}}}"

    # Return processing output for manifest.
    return Output(kind=kind, name=name, template=template.lstrip())


def filter_kinds(kinds: list[str], outputs: list[Output]) -> list[Output]:
    return [output for output in outputs if output.kind in kinds]


def generate_crds(chart_path: str, outputs: list[Output]):
    for output in outputs:
        crd_path = f"{chart_path}/crds/{output.name.split('.')[0]}.yaml"
        print(f"Writing 1 crd manifest to {crd_path}")
        with open(crd_path, "w", encoding=ENCODING) as outfile:
            outfile.write(output.template)


def generate_pdb(chart_path: str):
    template_path = f"{chart_path}/templates/pdb.yaml"
    print(f"Writing 1 template manifest to {template_path}")
    with open(template_path, "w", encoding=ENCODING) as outfile:
        outfile.write(PDB_TEMPLATE)


def generate_templates(chart_path: str, name: str, outputs: list[Output]):
    template = "---\n".join([output.template for output in outputs])
    template_path = f"{chart_path}/templates/{name}.yaml"
    num_outputs = len(outputs)
    print(f"Writing {num_outputs} template {'manifest' if num_outputs == 1 else 'manifests'} to {template_path}")
    with open(template_path, "w", encoding=ENCODING) as outfile:
        outfile.write(template)


def main(config_path: str, chart_path: str):
    # Create the chart.
    makedirs(CHARTS_DIR, exist_ok=True)
    run(f"helm create {CHART}", shell=True)
    run(f"rm {CHART}/templates/*.yaml", shell=True)
    run(f"rm -rf {CHART}/templates/tests", shell=True)

    # Update the generated Chart.yaml with app description and version.
    updated = []
    with open(CHART_YAML_FILE, encoding=ENCODING) as infile:
        lines = infile.readlines()
        for line in lines:
            if line.startswith("description:"):
                updated.append(f"description: {APP_DESCRIPTION}\n")
            elif line.startswith("version:"):
                updated.append(f"version: {APP_VERSION}\n")
            elif line.startswith("appVersion:"):
                updated.append(f'appVersion: "{APP_VERSION}"\n')
            else:
                updated.append(line)
    with open(CHART_YAML_FILE, "w") as outfile:
        outfile.writelines(updated)

    # Update the generated chart values.yaml image repository and app-specific config.
    updated = []
    with open(VALUES_YAML_FILE, "r", encoding=ENCODING) as infile:
        lines = infile.readlines()
        for line in lines:
            if line.startswith("  repository:"):
                updated.append(f"  repository: {IMAGE_NAME}\n")
            else:
                updated.append(line)
    updated.append(APP_SPECIFIC_VALUES_YAML)
    with open(VALUES_YAML_FILE, "w", encoding=ENCODING) as outfile:
        outfile.writelines(updated)

    # Get the manifests text generated by kustomize.
    proc = run(f"bin/kustomize build {config_path}", shell=True, stdout=PIPE)
    text = proc.stdout.decode(ENCODING).rstrip()
    manifests = text.split("---")
    num_manifests = len(manifests)
    print(f"Processing {num_manifests} input manifests generated by 'bin/kustomize build {config_path}' command")

    # Process all manifests.
    outputs = [process_manifest(manifest) for manifest in manifests]
    outputs.append(Output(kind=PDB_KIND, name=APP_NAME, template=PDB_TEMPLATE))

    # Group manifests.
    outputs_groups = {
        "crd": filter_kinds([CRD_KIND], outputs),
        "configmap": filter_kinds([CONFIGMAP_KIND], outputs),
        "deployment": filter_kinds([DEPLOYMENT_KIND], outputs),
        "pdb": filter_kinds([PDB_KIND], outputs),
        "rbac": filter_kinds(RBAC_KINDS, outputs),
        "prometheus": filter_kinds([SERVICE_MONITOR_KIND], outputs)
    }

    num_outputs = sum([len(outputs) for outputs in outputs_groups.values()])
    if num_outputs != num_manifests:
        print(f"Generated unexpected number of output manifests. should be {num_manifests}")
        exit(1)

    # Write out chart crds.
    makedirs(path.join(chart_path, "crds"), exist_ok=True)
    generate_crds(chart_path, outputs_groups["crd"])

    # Write out chart templates.
    for name, outputs in outputs_groups.items():
        if name == "crd":
            continue
        generate_templates(chart_path, name, outputs)

    # Empty notes template.
    open(f"{CHART}/templates/NOTES.txt", "w", encoding=ENCODING).close()

    # Lint chart.
    run(f"helm lint charts/{APP_NAME}", shell=True)


if __name__ == '__main__':
    parser = ArgumentParser(description="Generate helm chart for kubebuilder operator from its kustomize config.",
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("-s", "--src", metavar="PATH", default="config/default", help="source kustomize config")
    parser.add_argument("-d", "--dst", metavar="PATH", default=f"charts/{APP_NAME}",  help="destination helm chart")
    args = parser.parse_args()

    if not path.exists(args.src):
        print(f"error: src kustomize config {args.src} not found")
        exit(1)

    main(config_path=args.src, chart_path=args.dst)
